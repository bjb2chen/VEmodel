#!python3

# system imports
import shutil
from shutil import copyfile
import itertools as it
import glob
import sys
import os
from os.path import join

# third party imports
from scipy.interpolate import interp1d
import numpy as np

# local imports
import prop_input_template
from project_parameters import *
from vibronic import vIO, VMK
#
# sys.path.insert(0, os.path.abspath("/home/ngraymon/public/songhao/t_amplitudes_project/t-amplitudes"))  # TEMPORARY
# import project
# from project.vibronic_hamiltonian import vibronic_hamiltonian


nof_points = 3000

eV_dict = {
    "h2o":  (21, 11),
    "ch2o": (19, 9.5),
    "co2":  (20, 13),
    "n2o":  (21, 11.5),
    "nh3":  (19, 9),
    #
    "h2o2":      (20.5, 8),
    "hcooh":     (20, 8),
    "furan":     (20, 13),
    "formamide": (22, 13),
    "vcm":       (18, 9.5),
    #
    "op_nh36Q_5st":  (11, 2),
    f"{project_name}": (19, 3)
}

y_dict = {
    "h2o":  (-1.5, 60),
    "ch2o": (-1.5, 50),
    "co2":  (-1.5, 100),
    "n2o":  (-1.5, 100),
    "nh3":  (-1.5, 40),
    #
    "h2o2":      (-1.5, 14),
    "hcooh":     (-1.5, 16),
    "furan":     (-1.5, 40),
    "formamide": (-1.5, 15),
    "vcm":       (-1.5, 34),
    #
    "op_nh36Q_5st":       (-1.5, 40),
    f"{project_name}": (-1.5, 30)
}

left_eV, right_EV = eV_dict[project_name]
min_y, max_y = y_dict[project_name]
# min_EV, max_EV = 40, 5
tau = 40
iexp = 1


# -------------------------------------------------------------------------------------------------
def calculate_harmonic_ground_state_of_model(model):
    """Calculate the H.O. contribution to the electronic ground state"""
    harmonic_ground_state = round(0.5 * np.sum(model[VMK.w]), ndigits=9)
    return harmonic_ground_state


def calculate_harmonic_ground_state_of_op_file(path):
    """Calculate the H.O. contribution to the electronic ground state of an '.op' file"""
    model = vIO.extract_excited_state_model_op(f"./{model_name}.op")
    return calculate_harmonic_ground_state_of_model(model)


# -------------------------------------------------------------------------------------------------
# def modify_acf_file(root, path_cc, path_mctdh, mctdh_t_final=None, mctdh_step=None):

#     def extract_from_auto_file(path_auto):
#         t, _ = vibronic_hamiltonian.load_auto_data(path_auto)
#         tf = round(float(t[-1] / 2), ndigits=8)
#         dt = round(float(t[1]-t[0]) / 2, ndigits=8)
#         return tf, dt

#     if mctdh_t_final is None and mctdh_step is None:
#         mctdh_t_final, mctdh_step = extract_from_auto_file(join(root, path_mctdh))

#     try:
#         time, acf = vibronic_hamiltonian.load_acf_data(join(root, path_cc))
#     except Exception as e:
#         print(f"Numerical issues with {path_cc}")
#         print(e)
#         return False

#     print(time.shape)
#     print(time[0], time[1], time[-2], time[-1])
#     print(len(time), len(acf))

#     # if the last two points are the same
#     try:
#         # create interpolation objects
#         f_real = interp1d(time, acf.real, 'cubic')
#         f_imag = interp1d(time, acf.imag, 'cubic')
#     except ValueError as e:
#         print("Most likely the rray has duplicate t values, this needs to be changed when executing")
#         raise e
#         # print(time[-2], time[-1])
#         # time[-1] = round(time[-1] + 1E-7, ndigits=8)
#         # print(time[-2], time[-1])
#         # f_real = interp1d(time, acf.real, 'cubic')
#         # f_imag = interp1d(time, acf.imag, 'cubic')

#     cc_t_init, cc_t_final = time[0], time[-1]
#     print(cc_t_init, cc_t_final, mctdh_t_final)
#     npoints = int(mctdh_t_final / mctdh_step)
#     print(f"Nof points = {npoints}")
#     # if we use endpoint=True then its very difficult to get good deltas
#     # so for now we will use endpoint=False
#     _, dt = np.linspace(cc_t_init, cc_t_final, num=npoints, endpoint=False, retstep=True)
#     time_step = round(dt, ndigits=8)
#     print(f"Time step is {time_step:12.8f}")
#     # then we make sure we generate uniformly spaced points
#     # we use (cc_t_final+time_step) because np.arange doesn't include the last point
#     # so if we want to include cc_t_final (we do) then we need to make the 'last point' one step after the point that we want to be the real 'last point'
#     new_x = np.arange(cc_t_init, cc_t_final+time_step, step=time_step, dtype=float)

#     print(new_x[0], new_x[-1])

#     new_time = new_x.copy()
#     for i in range(len(new_x)):
#         new_time[i] = round(new_x[i], ndigits=8)

#     new_acf = np.zeros_like(new_x, dtype=complex)
#     dt = abs(new_time[0] - new_time[1])
#     arr = abs(new_time[0:-2] - new_time[1:-1])
#     for i, a in enumerate(arr):
#         assert np.isclose(dt, a)

#     # save interpolated data to new_acf array
#     new_acf.real = f_real(new_x)
#     new_acf.imag = f_imag(new_x)

#     # normalize the results (to match MCTDH)
#     normalization_factor = new_acf.real[0]
#     print(f"\nNormalization factor: {normalization_factor}\n")
#     new_acf.real /= normalization_factor
#     new_acf.imag /= normalization_factor

#     # strip '.txt' off path and add the suffix '_normalized.txt'
#     new_path = path_cc[0:-4:]+"_normalized.txt"
#     vibronic_hamiltonian._save_data(join(root, new_path), new_time, new_acf)
#     return new_path


# -------------------------------------------------------------------------------------------------
def _generate_pl(nof_points, root_dir, output_filename, input_filename):
    """Generate command string to call `autospec84` to generate spectrum data points"""
    if "vibronic" in input_filename:
        # if "tf50" in input_filename:
        if "tf100" in input_filename:
            nof_points = 5000
        if "tf500" in input_filename:
            nof_points = 62000
        if "tf1000" in input_filename:
            nof_points = 65000

    command = (
        #
        f"cd {root_dir}; "  # temporary fix!!!!!! TEMPORARY
        #
        "autospec84 "
        # "-g 1 "  # to print gnuplot commands or not
        f"-o {output_filename:s} "
        f"-f {input_filename:s} "
        f"-p {nof_points:d} "
        # f"-EP "
        # f"-e {harmonic_ground_state} eV " # x axis shift (left/right) to account for H.O. G.S.
        f"{left_eV} {right_EV} eV "  # x axis limits (in eV)
        f"{tau:d} "   # tau value
        f"{iexp:d} "  # iexp value
    )
    return command


def generate_cc_pl(nof_points, root_dir, output_filename, input_filename):
    """Generate command string to call `autospec84` to generate spectrum data points for CC"""
    return _generate_pl(nof_points, root_dir, output_filename, input_filename)


def generate_mctdh_pl(nof_points, root_dir, output_filename, input_filename):
    """Generate command string to call `autospec84` to generate spectrum data points for MCTDH"""
    return _generate_pl(nof_points, root_dir, output_filename, input_filename)


# -------------------------------------------------------------------------------------------------
# def write_cc_mctdh_spectrum_plotting_file(configuration, *args):
#     """ a """

#     # unpack arguments
#     nof_points, root_dir, mctdh_file, cc_file, model_name, pbf, t = args
#     # print(f'{root_dir}/{mctdh_file}.pl')
#     # print(f'{root_dir}/{cc_file}.pl')
#     # doctor the file name to make it look better in the plot
#     plot_title = model_name.replace('_', ' ').replace('h2o', 'h_{2}o')

#     size = [1200, 800]
#     # size = [800, 400]

#     output_file = f'{root_dir}/both_spectrum_{model_name:s}_{nof_points:d}_PBF{pbf:d}_{int(t):d}fs_{tau:d}tau.png'

#     plotting_command = '\n'.join([
#         f"set terminal png size {size[0]},{size[1]}",
#         # f"set output './spectrum_{model_name:s}_{nof_points:d}_{t_final:d}fs_{tau:d}tau_{nof_BF}SOSBF_{mctdh_BF}{configuration}BF.png'",
#         f"set output '{output_file:s}'",
#         "set style data line", "set nologscale", "set xzeroaxis", "set xlabel 'Energy[eV]'",
#         f"set xr [ {left_eV}: {right_EV}]",
#         f"set yr [ {min_y}: {max_y}]",
#         f"set title '{plot_title:s} spectrum, n-cos = 1, tau: {tau:d}.0 1, {int(t):d}fs'",
#         f"plot \
#             '{root_dir}/{mctdh_file}.pl' using 1:3 lw 2 lc 'black' title '{configuration}',\
#             '{root_dir}/{cc_file}.pl' every 6 using 1:3 with linespoints lc 'purple' title 'CC',\
#         ",
#         # '{sos_file}.pl' using 1:3 lc 'black' title 'SOS',\
#     ])

#     path_plotting_file = f"{root_dir}/spectrum_plotting.pl"

#     # write the plotting commands to a file
#     with open(path_plotting_file, 'w') as fp:
#         fp.write(plotting_command)

#     return path_plotting_file, output_file


def write_spectrum_plotting_file(configuration, *args):
    """ a """

    # unpack arguments
    nof_points, root_dir, mctdh_file, model_name, pbf, t, operate_string = args
    # print(f'{root_dir}/{mctdh_file}.pl')
    # doctor the file name to make it look better in the plot
    plot_title = model_name.replace('_', ' ').replace('h2o2', 'h_{2}o_{2}')
    plot_title = model_name.replace('_', ' ').replace('h2o', 'h_{2}o')

    size = [1200, 800]
    # size = [800, 400]

    output_file = f'{root_dir}/{configuration}_spectrum_{model_name:s}_{nof_points:d}_PBF{pbf:d}_{int(t):d}fs_{tau:d}tau_{operate_string}.png'

    plotting_command = '\n'.join([
        f"set terminal png size {size[0]},{size[1]}",
        # f"set output './spectrum_{model_name:s}_{nof_points:d}_{t_final:d}fs_{tau:d}tau_{nof_BF}SOSBF_{mctdh_BF}{configuration}BF.png'",
        f"set output '{output_file:s}'",
        "set style data line", "set nologscale", "set xzeroaxis", "set xlabel 'Energy[eV]'",
        # f"set xr [ 0.{left_eV}00000E+02: 0.{right_EV}0000E+02]",
        f"set xr [ {left_eV}: {right_EV}]",
        f"set yr [ {min_y}: {max_y}]",
        f"set title '{plot_title:s} spectrum, n-cos = 1, tau: {tau:d}.0 1, {int(t):d}fs'",
        f"plot \
            '{root_dir}/{mctdh_file}_{operate_string}.pl' using 1:3 lw 2 lc 'black' title '{configuration} g1',\
            '{root_dir}/{mctdh_file}_{operate_string}.pl' using 1:4 lw 2 lc 'red' title '{configuration} g2',\
        ",
        # '{cc_file}.pl' every 6 using 1:3 with linespoints lc 'purple' title 'CC',\
        # '{sos_file}.pl' using 1:3 lc 'black' title 'SOS',\
    ])

    path_plotting_file = f"{root_dir}/spectrum_plotting.pl"

    # write the plotting commands to a file
    with open(path_plotting_file, 'w') as fp:
        fp.write(plotting_command)

    return path_plotting_file, output_file


# def write_mctdh_pbf_spectrum_plotting_file(configuration, *args):
#     """Generate gnuplot script for comparing multiple MCTDH results for different #'s of PBF's """

#     # unpack arguments
#     nof_points, root_dir, spectrum_dir, model_name, t = args
#     # print(f'{root_dir}/{mctdh_file}.pl')
#     # doctor the file name to make it look better in the plot
#     plot_title = model_name.replace('_', ' ').replace('h2o', 'h_{2}o')

#     size = [1200, 800]
#     # size = [800, 400]

#     output_file = f'{spectrum_dir}/combined_{configuration}_spectrum_{model_name:s}_{nof_points:d}_{int(t):d}fs_{tau:d}tau.png'
#     d_30 = dir_string.format(model_name, 30, t)
#     d_100 = dir_string.format(model_name, 100, t)
#     d_300 = dir_string.format(model_name, 300, t)
#     d_500 = dir_string.format(model_name, 500, t)
#     d_1000 = dir_string.format(model_name, 1000, t)

#     plotting_command = '\n'.join([
#         f"set terminal png size {size[0]},{size[1]}",
#         # f"set output './spectrum_{model_name:s}_{nof_points:d}_{t_final:d}fs_{tau:d}tau_{nof_BF}SOSBF_{mctdh_BF}MCTDHBF.png'",
#         f"set output '{output_file:s}'",
#         "set style data line", "set nologscale", "set xzeroaxis", "set xlabel 'Energy[eV]'",
#         # f"set xr [ 0.{left_eV}00000E+02: 0.{right_EV}0000E+02]",
#         f"set xr [ {left_eV}: {right_EV}]",
#         f"set yr [ {min_y}: 30.0]",
#         f"set title '{plot_title:s} spectrum, n-cos = 1, tau: {tau:d}.0 1, {int(t):d}fs'",
#         f"plot \
#             '{root_dir}/{d_30}/{configuration}_spectrum_{d_30}.pl' using 1:3 lw 2 lc 'red' title '30 PBF',\
#             '{root_dir}/{d_100}/{configuration}_spectrum_{d_100}.pl' using 1:3 lw 2 lc 'green' title '100 PBF',\
#             '{root_dir}/{d_300}/{configuration}_spectrum_{d_300}.pl' using 1:3 lw 2 lc 'yellow' title '300 PBF',\
#             '{root_dir}/{d_500}/{configuration}_spectrum_{d_500}.pl' using 1:3 lw 2 lc 'blue' title '500 PBF',\
#             '{root_dir}/{d_1000}/{configuration}_spectrum_{d_1000}.pl' using 1:3 lw 2 lc 'black' title '1000 PBF',\
#         ",
#         # '{cc_file}.pl' every 6 using 1:3 with linespoints lc 'purple' title 'CC',\
#         # '{sos_file}.pl' using 1:3 lc 'black' title 'SOS',\
#     ])

#     path_plotting_file = f"{spectrum_dir}/spectrum_plotting.pl"

#     # write the plotting commands to a file
#     with open(path_plotting_file, 'w') as fp:
#         fp.write(plotting_command)

#     return path_plotting_file, output_file


# def write_mctdh_tf_spectrum_plotting_file(configuration, *args):
#     """Generate gnuplot script for comparing multiple MCTDH results for different lengths of propagation """

#     # unpack arguments
#     nof_points, root_dir, mctdh_file, model_name, pbf, t = args
#     print(f'{root_dir}/{mctdh_file}.pl')
#     # doctor the file name to make it look better in the plot
#     plot_title = model_name.replace('_', ' ').replace('h2o', 'h_{2}o')

#     size = [1200, 800]
#     # size = [800, 400]

#     plotting_command = '\n'.join([
#         f"set terminal png size {size[0]},{size[1]}",
#         # f"set output './spectrum_{model_name:s}_{nof_points:d}_{t_final:d}fs_{tau:d}tau_{nof_BF}SOSBF_{mctdh_BF}MCTDHBF.png'",
#         f"set output '{root_dir}/spectrum_{model_name:s}_{nof_points:d}_PBF{pbf:d}_{int(t):d}fs_{tau:d}tau.png'",
#         "set style data line", "set nologscale", "set xzeroaxis", "set xlabel 'Energy[eV]'",
#         # f"set xr [ 0.{left_eV}00000E+02: 0.{right_EV}0000E+02]",
#         f"set xr [ {left_eV}: {right_EV}]",
#         f"set yr [ {min_y}: {max_y}]",
#         f"set title '{plot_title:s} spectrum, n-cos = 1, tau: {tau:d}.0 1, {int(t):d}fs'",
#         f"plot \
#             '{root_dir}/{mctdh_file}.pl' using 1:3 lw 2 lc 'black' title '{configuration}',\
#         ",
#         # '{cc_file}.pl' every 6 using 1:3 with linespoints lc 'purple' title 'CC',\
#         # '{sos_file}.pl' using 1:3 lc 'black' title 'SOS',\
#     ])

#     path_plotting_file = "spectrum_plotting.pl"

#     # write the plotting commands to a file
#     with open(path_plotting_file, 'w') as fp:
#         fp.write(plotting_command)

#     return path_plotting_file


# def write_mctdh_coupling_spectrum_plotting_file(configuration, *args):
#     """Generate gnuplot script for comparing multiple MCTDH results between constant/linear/quadratic coupling terms """

#     # unpack arguments
#     nof_points, root_dir, mctdh_file, model_name, pbf, t = args
#     print(f'{root_dir}/{mctdh_file}.pl')
#     # doctor the file name to make it look better in the plot
#     plot_title = model_name.replace('_', ' ').replace('h2o', 'h_{2}o')

#     size = [1200, 800]
#     # size = [800, 400]

#     plotting_command = '\n'.join([
#         f"set terminal png size {size[0]},{size[1]}",
#         # f"set output './spectrum_{model_name:s}_{nof_points:d}_{t_final:d}fs_{tau:d}tau_{nof_BF}SOSBF_{mctdh_BF}MCTDHBF.png'",
#         f"set output '{root_dir}/spectrum_{model_name:s}_{nof_points:d}_PBF{pbf:d}_{int(t):d}fs_{tau:d}tau.png'",
#         "set style data line", "set nologscale", "set xzeroaxis", "set xlabel 'Energy[eV]'",
#         # f"set xr [ 0.{left_eV}00000E+02: 0.{right_EV}0000E+02]",
#         f"set xr [ {left_eV}: {right_EV}]",
#         f"set yr [ {min_y}: {max_y}]",
#         f"set title '{plot_title:s} spectrum, n-cos = 1, tau: {tau:d}.0 1, {int(t):d}fs'",
#         f"plot \
#             '{root_dir}/{mctdh_file}.pl' using 1:3 lw 2 lc 'black' title '{configuration}',\
#         ",
#         # '{cc_file}.pl' every 6 using 1:3 with linespoints lc 'purple' title 'CC',\
#         # '{sos_file}.pl' using 1:3 lc 'black' title 'SOS',\
#     ])

#     path_plotting_file = "spectrum_plotting.pl"

#     # write the plotting commands to a file
#     with open(path_plotting_file, 'w') as fp:
#         fp.write(plotting_command)

#     return path_plotting_file


# def write_acf_plotting_file(configuration, *args):
#     """ a """

#     # unpack arguments
#     # nof_points, mctdh_file, model_name = args
#     # nof_points, cc_file, mctdh_file, cc_file2, model_name = args

#     # doctor the file name to make it look better in the plot
#     plot_title = model_name.replace('_', ' ').replace('h2o', 'h_{2}o')

#     size = [1200, 800]
#     # style = "circle radius graph 0.002"
#     # style = "line 1 lc rgb '#0060ad' lt 1 lw 2 pt 7 pi -1 ps 1.5"
#     style = "line 1 lt 2 pt 12 ps 1 pi -1"

#     plotting_command = '\n'.join([
#         f"set terminal png size {size[0]},{size[1]}",
#         f"set title 'ACF comparison of {t_final:d}fs'",
#         f"set style {style}", "set style data line",
#         # "set pointintervalbox 2",
#         f"set output './ACF_{model_name:s}_{nof_points:d}_{t_final:d}fs.png'",
#         "set nologscale", "set xzeroaxis", "set ylabel 'C(tau/hbar)'",
#         "set yr [ -1: 1]",
#         "set xr [ 0.0: 100.0]",
#         f"plot \
#             '{mctdh_file}' us 1:2 with linespoints ls 4 ps 3 lc 'red' title '{configuration} Real',\
#             '{cc_file}' us 1:2 lc 'green' title 'CC Real (interpolated)',\
#         ",
#         # '{cc_file2}' us 1:2 with linespoints ls 1 lc 'blue' title 'CC Real (raw RK45)'\
#     ])

#     path_plotting_file = "acf_plotting.pl"

#     # write the plotting commands to a file
#     with open(path_plotting_file, 'w') as fp:
#         fp.write(plotting_command)

#     return path_plotting_file


# -------------------------------------------------------------------------------------------------
def create_spectrum():
    return


def create_spectrums():
    return


# -------------------------------------------------------------------------------------------------
def mctdh_job_is_finished(path_to_mctdh_execution_folder):
    """Return True if MCTDH job is finished, otherwise return False."""

    path_to_output_file = join(path_to_mctdh_execution_folder, "output")

    if os.path.exists(path_to_output_file):
        with open(path_to_output_file, 'r') as fp:
            data = fp.read()

        return bool("Propagation was successful." in data)

    return False
# -------------------------------------------------------------------------------------------------


def store_job_state(name, job_state_dictionary, tf_value):
    """ Record the job into a state_dictionary """
    if name not in job_state_dictionary:
        job_state_dictionary[name] = [tf_value, ]  # initialize a new entry as a list
    else:
        job_state_dictionary[name].append(tf_value)  # append to the already existing list


def print_summarized_output(completed_jobs, not_submitted_jobs, failed_jobs, running_jobs):
    tfds = thirty_five_dashes = "-"*35

    print(f"{tfds}  Successfully Completed jobs  {tfds}\n")
    for key in completed_jobs.keys():
        print(f"{key}, tf:", completed_jobs[key])

    print(f"{tfds}  Not Submitted jobs  {tfds}\n")
    for key in not_submitted_jobs.keys():
        print(f"{key}, tf:", not_submitted_jobs[key])

    print(f"{tfds}  Failed jobs  {tfds}\n")
    for key in failed_jobs.keys():
        print(f"{key}, tf:", failed_jobs[key])

    print(f"{tfds}  Running jobs  {tfds}\n")
    for key in running_jobs.keys():
        print(f"{key}, tf:", running_jobs[key])

    return


def plot_spectra_wrapper(root_dir, spectrum_dir, model_name, *args, **kwargs):
    """ Calls a bunch of other functions to prepare a bunch of strings
    to give as input arguments to `gnuplot` to plot the result of running
    `autospec` on various files.
    """
    configuration, path_mctdh_spectrum, operate_string = *args

    # -------------------------------------------------------------------------------------------------
    if True:  # plotting singular spectrums
        plotting_file, output_file = write_spectrum_plotting_file(
            configuration, nof_points, root_dir, path_mctdh_spectrum, model_name, *param_list, operate_string
        )
        os.system(f"gnuplot {plotting_file}")
        shutil.copy(output_file, spectrum_dir)

    if False:  # plotting combined spectrums
        plotting_file, output_file = write_cc_mctdh_spectrum_plotting_file(
            configuration, nof_points, root_dir, path_mctdh_spectrum, path_cc_spectrum, model_name, *param_list
        )
        os.system(f"gnuplot {plotting_file}")
        shutil.copy(output_file, spectrum_dir)

    if False:
        # this `auto_path` is only used for plotting ACF of VECC or SOS
        auto_path = f"./h2o_FC_{order:s}_{25:>03d}fs_{BF:>03d}BF_{spf:>02d}spf/auto"

        if False:  # plotting ACF
            plotting_file = write_acf_plotting_file(configuration, nof_points, new_cc_acf, auto_path)
            os.system(f"gnuplot {plotting_file}")

        if False:  # plotting ACF vs SOS
            plotting_file = write_acf_sos_plotting_file(configuration, nof_points, new_cc_acf, auto_path, new_sos_acf)
            os.system(f"gnuplot {plotting_file}")

    return


# -------------------------------------------------------------------------------------------------


if (__name__ == "__main__"):

    spectrum_dir = join(work_root, "0_spectrums/")
    auto_dir = join(work_root, "0_auto_dir/")
    os.makedirs(spectrum_dir, exist_ok=True)
    os.makedirs(auto_dir, exist_ok=True)

    configuration = "tdh" if ("/tdh/" in work_root) else "mctdh"

    only_checking_output = False
    suppress_autosped84_ouptut = False
    generating_cc = False

    # temporarily plot combined MCTDH
    if False:
        coupling_order = "quadratic"
        FC_or_not = "vibronic"
        model_name = "_".join([project_name, FC_or_not, coupling_order])

        for t in t_final:
            plotting_file, output_file = write_mctdh_pbf_spectrum_plotting_file(
                nof_points, work_root, spectrum_dir, model_name, t
            )
            os.system(f"gnuplot {plotting_file}")

        sys.exit(0)

    # ---------------------------------------------------------------------------------------------
    # job_state_dictionaries -> store the state of each job in one of these dictionaries
    failed_jobs = {}
    running_jobs = {}
    completed_jobs = {}
    not_submitted_jobs = {}
    # ---------------------------------------------------------------------------------------------

    model_name = project_name

    for param_list in it.product(*expression_list):
        print(param_list)  # for debugging

        # the name we will store in one of the job_state_dictionaries
        pbf, tf = param_list
        job_state_key = f"pbf{pbf}"

        calculation_spec = dir_string.format(model_name, *param_list)
        for operate_string in ["Ex", "Ey", "Ez"]:

            # -------------------------------------------------------------------------------------------------
            # prepare file paths
            # -------------------------------------------------------------------------------------------------

            root_dir = join(work_root, calculation_spec, operate_string)
            print(f'root_dir: {root_dir}')

            path_mctdh_acf = join(model_name, "auto")
            if False: print("path_mctdh_acf", path_mctdh_acf, "\n")

            path_mctdh_spectrum = f"{configuration}_spectrum_{dir_string.format(model_name, *param_list)}"
            if False: print("path_mctdh_spectrum", path_mctdh_spectrum, "\n")

            path_to_mctdh_execution_folder = join(root_dir, model_name)

            if not os.path.isdir(path_to_mctdh_execution_folder):  # if no folder, job was not even submitted
                print(f"{configuration.upper()} job has not yet been submitted {model_name} Parameters: {param_list}")
                store_job_state(job_state_key, not_submitted_jobs, tf)
                continue

            elif mctdh_job_is_finished(path_to_mctdh_execution_folder):  # if slurm seems done then job might be finished

                if only_checking_output:
                    """ If we just want to check how many jobs failed / haven't been submitted then simply skip all the code following here and continue with the loop.
                    This means we won't try to make ACF or Spectra but simply read the MCTDH job output files for job status.
                    """
                    continue

                # build string to execute autospec to generate spectra
                command = generate_mctdh_pl(
                    nof_points,
                    root_dir=root_dir,
                    output_filename=f"{path_mctdh_spectrum}_{operate_string}",
                    input_filename=path_mctdh_acf
                )
                if verbose: print(command)  # for debugging

                if suppress_autosped84_ouptut:  # run autospec
                    os.system(command + ' 1> /dev/null')
                else:
                    print('\n'); os.system(command); print('\n')

                # finished
                print(f'Autospecd {model_name} Parameters: {param_list}')
                store_job_state(job_state_key, completed_jobs, tf)

                # copy auto files (output of the MTCDH calculation) to the directory where we compute the spectra
                src_ACF_path = join(path_to_mctdh_execution_folder, 'auto')
                dst_ACF_path = join(auto_dir, f"auto_{calculation_spec}_{operate_string}")
                print(f'src_ACF_path: {src_ACF_path}')
                print(f'dst_ACF_path: {dst_ACF_path}')
                shutil.copy(src_ACF_path, dst_ACF_path)

                # attempt to plot spectra
                spectra_args = configuration, path_mctdh_spectrum, operate_string
                plot_spectra_wrapper(root_dir, spectrum_dir, model_name, *spectra_args)

            else:  # job is running/failed

                # check for issue in latest slurm output
                # -------------------------------------------------------------------------------------------------

                paths = glob.glob(join(root_dir, 'slurm-*.out'))
                latest_slurm_file = sorted(paths, reverse=True)[0]
                if not os.path.isfile(latest_slurm_file):
                    print(f"Malformed slurm file {latest_slurm_file} Parameters: {param_list}")
                    continue

                # -------------------------------------------------------------------------------------------------
                # if the file exists and is readable -> then try to find out why the job failed
                else:
                    # read in output from slurm job (and convert to lowercase)
                    with open(latest_slurm_file, 'r') as fp:
                        data = fp.read()
                        lowercase_data = data.lower()

                    error_string_list = [  # possible reasons for failure
                        'memory limit', 'killed', 'error', 'cancelled',
                    ]

                    for string in error_string_list:
                        if string in lowercase_data:
                            if 'memory limit' in data:
                                print(f"FAIL: {configuration.upper()} job failed due to memory limits {model_name} Parameters: {param_list}")
                            elif 'CANCELLED' in data:
                                print(f"FAIL: {configuration.upper()} job was cancelled {model_name} Parameters: {param_list}")
                            else:
                                print(f"FAIL: {configuration.upper()} job failed for some reason {model_name} Parameters: {param_list}")

                            store_job_state(job_state_key, failed_jobs, tf)

                            if configuration == "mctdh":
                                # ldir = abspath(f"/work/{user_root}/{parent_project}/mctdh/{project_name}/{calculation_spec}/{model_name}/")
                                ldir = abspath(f"/work/{user_root}/mctdh/{project_name}/{calculation_spec}/{model_name}/")
                                # delete the super large files
                                for file_name in ["psi", "dvr", "restart", "oper"]:
                                    target = join(ldir, file_name)
                                    if os.path.exists(target):
                                        print(f'rm {target}')
                                        os.system(f'rm {target}')
                            continue

                    else:  # if we don't find any `string` in `lowercase_data` then the job is probably still running
                        # this can happen every now and then when the job is ALMOST finished, but the files haven't updated yet
                        print(f"{configuration.upper()} job is not finished! {model_name} Parameters: {param_list}")

                        store_job_state(job_state_key, running_jobs, tf)

                    continue

        # end-of-loop

    # end-of-loop

    print_summarized_output(completed_jobs, not_submitted_jobs, failed_jobs, running_jobs)
